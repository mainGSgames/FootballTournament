<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sega Football Stream Overlay v2</title>
    <style>
        :root {
            --accent: #10b981; /* Emerald green */
            --bg: #0f172a; /* Fallback bg if camera fails */
            --fg: #f8fafc; /* Slate light */
            --card: #1e293b; /* For setup screens */
            --overlay-bg: rgba(15, 23, 42, 0.75); /* Slightly more opaque */
            --player1-color: #3b82f6; /* Blue */
            --player2-color: #ef4444; /* Red */
            --timer-color: #f59e0b; /* Amber */
            --button-size: clamp(40px, 7vh, 55px); /* Slightly smaller buttons */
            --font-size-large: clamp(1.4rem, 4.5vh, 2.8rem); /* Slightly smaller */
            --font-size-medium: clamp(0.9rem, 2.8vh, 1.6rem); /* Slightly smaller */
            --font-size-small: clamp(0.75rem, 2.2vh, 1.1rem); /* Slightly smaller */
            --border-color: #475569;
            --input-bg: #334155;
            --win-color: var(--accent);
            --loss-color: #f43f5e;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
        html, body { height: 100%; width: 100%; overflow: hidden; background-color: var(--bg); color: var(--fg); }

        button { background: var(--accent); color: #fff; border: none; border-radius: 0.5rem; font-weight: 600; cursor: pointer; padding: 0.5em 1em; transition: transform 0.1s ease; font-size: var(--font-size-small); }
        button:hover { transform: scale(1.03); }
        button.icon-button { padding: 0; width: var(--button-size); height: var(--button-size); font-size: calc(var(--button-size) * 0.5); display: flex; align-items: center; justify-content: center; border-radius: 50%; }
        button.secondary { background: var(--card); }

        /* --- Setup/Non-Stream Views (mostly unchanged) --- */
        #app { width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; }
        .card { background: var(--card); padding: clamp(0.5rem, 2vw, 1rem); border-radius: 1rem; margin-bottom: 1rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); max-width: 700px; width: 90%; overflow-y: auto; max-height: 85vh; }
        .player-row { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; }
        .player-color-static { width: 32px; height: 32px; border-radius: 50%; border: 2px solid #fff; flex-shrink: 0; cursor: pointer; }
        .player-input { flex-grow: 1; background-color: var(--input-bg); color: var(--fg); border: 1px solid var(--border-color); padding: 0.5rem; border-radius: 0.3rem; font-size: var(--font-size-small);}
        input[type="color"] { width: 40px; height: 40px; padding: 0; border: none; background: transparent; cursor: pointer; flex-shrink: 0; }
        input[type="number"] { width: 60px; padding: 0.5rem; background: var(--input-bg); color: var(--fg); border: 1px solid var(--border-color); border-radius: 0.3rem; text-align: center; -moz-appearance: textfield; font-size: var(--font-size-small); }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .settings-row { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .settings-row label { flex-basis: 150px; flex-shrink: 0; font-size: var(--font-size-small); }
        .group-title, .section-title { font-size: var(--font-size-medium); margin-bottom: 0.75rem; color: var(--accent); border-bottom: 1px solid var(--accent); padding-bottom: 0.3rem; }
        /* --- Standings/Bracket (unchanged) --- */
        .standings { margin-top: 1rem; font-size: var(--font-size-small); overflow-x: auto; } .standings table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; } .standings th, .standings td { padding: 0.4rem 0.2rem; text-align: center; white-space: nowrap; } .standings tr:nth-child(even) { background: #334155; } .standings th { background: var(--accent); color: var(--bg); font-weight: bold; } .standings .player-name-col { text-align: left; padding-left: 0.5rem; }
        .playoff-bracket { margin-top: 1rem; } .playoff-round { margin-bottom: 1rem; border-left: 2px solid var(--border-color); padding-left: 1rem;} .playoff-match { display: flex; justify-content: space-between; align-items: center; padding: 0.3rem 0.5rem; border-bottom: 1px dashed var(--border-color); } .playoff-match .p-box { flex-basis: 40%; } .playoff-match .p-box .pname { font-size: var(--font-size-small); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;} .playoff-match .player-color-static { width: 20px; height: 20px; border-width: 1px;} .playoff-match .match-score { font-weight: bold; font-size: var(--font-size-small); } .p-box .pname.winner { color: var(--win-color); font-weight: bold;} .p-box .pname.loser { text-decoration: line-through; opacity: 0.7;}
        .champion-box { text-align: center; padding: 2rem; } .champion-box .player-name { font-size: calc(var(--font-size-large) * 1.1); color: var(--win-color); } .champion-box .player-color-static { width: clamp(60px, 15vh, 80px); height: clamp(60px, 15vh, 80px); margin: 0 auto 0.5rem auto; }
        .visualization { margin-top: 1rem; width: 100%; } .visualization svg { width: 100%; min-height: 150px; max-height: 30vh; background: var(--bg); border-radius: 0.5rem; border: 1px solid var(--card); } .qualifier-node { fill: var(--accent); } .qualifier-text { fill: var(--fg); font-size: 0.7rem; text-anchor: middle; } .qualifier-line { stroke: var(--fg); stroke-width: 1; opacity: 0.5; } .playoff-area-text { fill: var(--fg); font-size: 0.9rem; text-anchor: middle; font-weight: bold; }


        /* --- Stream View --- */
        #stream-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg); display: none; }
        #camera-feed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; background-color: #333; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; display: flex; flex-direction: column; pointer-events: none; padding: clamp(5px, 1vh, 10px); /* Reduced padding */ }

        /* Overlay Layout - Top, Spacer, Bottom */
        .overlay-top { display: flex; justify-content: space-between; /* Space out items */ align-items: center; padding: 0.3em 0.8em; background: var(--overlay-bg); border-radius: 0.5rem; pointer-events: auto; flex-shrink: 0; order: 1; /* Top */ }
        .overlay-spacer { flex-grow: 1; order: 2; /* Middle */ }
        .overlay-bottom { display: flex; flex-direction: column; /* Stack ticker and player bar */ align-items: center; order: 3; /* Bottom */ pointer-events: auto; flex-shrink: 0; width: 100%; }

        /* Top Bar Components */
        .match-info { font-size: var(--font-size-small); text-align: center; color: #ccc; flex-grow: 1; /* Allow text to take space */ margin: 0 1rem; }
        .timer-controls { display: flex; align-items: center; gap: 0.5rem;} /* Group timer and pause */
        .timer { font-size: var(--font-size-large); font-weight: bold; color: var(--timer-color); text-align: right; }
        .timer.paused { opacity: 0.6; }
        .pause-resume-button { width: calc(var(--button-size)*0.8); height: calc(var(--button-size)*0.8); font-size: calc(var(--button-size) * 0.4); } /* Smaller pause */

        /* Bottom Area Components */
        #previous-match-ticker {
            width: 80%; /* Or adjust as needed */
            background: rgba(0, 0, 0, 0.6);
            color: #eee;
            font-size: var(--font-size-small);
            padding: 0.3em 0.6em;
            border-radius: 0.3rem;
            margin-bottom: clamp(3px, 0.5vh, 5px);
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s ease-in-out;
        }
        #previous-match-ticker.visible { opacity: 1; }

        .player-bar { display: flex; justify-content: space-between; align-items: center; width: 100%; background: var(--overlay-bg); border-radius: 0.5rem; padding: clamp(3px, 0.8vh, 8px) clamp(8px, 1.5vw, 15px); }
        .player-info { display: flex; align-items: center; gap: clamp(5px, 1.5vw, 15px); flex-basis: 48%; /* Adjust space */ }
        .player-info.player2 { flex-direction: row-reverse; /* Right align P2 */ } /* Reverse order for P2 */
        .player-name { font-size: var(--font-size-medium); font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .player-score { font-size: var(--font-size-large); font-weight: bold; margin: 0 clamp(5px, 1vw, 10px); }
        .goal-button { background-color: var(--accent); flex-shrink: 0; }
         /* Player name color applied via JS */

        #exit-stream-button { position: fixed; bottom: 10px; right: 10px; z-index: 10; opacity: 0.7; } /* Corner exit button */

         /* Animation for ticker */
         @keyframes fadeInOut {
           0% { opacity: 0; }
           20% { opacity: 1; } /* Fade in quick */
           80% { opacity: 1; } /* Stay visible */
           100% { opacity: 0; } /* Fade out */
         }

         #previous-match-ticker.animate {
           animation: fadeInOut 7s ease-in-out forwards; /* Adjust duration */
         }

    </style>
</head>
<body>
    <div id="app"></div>
    <div id="stream-container">
        <video id="camera-feed" playsinline autoplay muted></video>
        <div id="overlay">
            <div class="overlay-top">
                 <div id="match-info" class="match-info"></div>
                 <div class="timer-controls">
                     <div id="timer" class="timer">00:00</div>
                     <button id="pause-resume-button" class="icon-button pause-resume-button">❚❚</button>
                 </div>
            </div>

            <div class="overlay-spacer"></div>

            <div class="overlay-bottom">
                 <div id="previous-match-ticker">Last Match: P1 2 - 1 P2</div> <div class="player-bar">
                    <div class="player-info player1">
                        <button id="player1-goal-button" class="icon-button goal-button">+</button>
                        <div id="player1-score" class="player-score">0</div>
                        <div id="player1-name" class="player-name">Player 1</div>
                    </div>
                    <div class="player-info player2">
                        <button id="player2-goal-button" class="icon-button goal-button">+</button>
                        <div id="player2-score" class="player-score">0</div>
                        <div id="player2-name" class="player-name">Player 2</div>
                    </div>
                 </div>
            </div>

             <button id="exit-stream-button" class="secondary">Exit</button>
        </div>
    </div>

    <script>
    (function() {
        const STORAGE_KEY = 'segaRR_v6_stream_layout';
        let state = null;
        let timerInterval = null;
        let cameraStream = null;
        let tickerInterval = null; // Interval ID for the previous match ticker

        // DOM Cache
        const appDiv = document.getElementById('app');
        const streamContainer = document.getElementById('stream-container');
        const cameraVideo = document.getElementById('camera-feed');
        // Other elements cached as needed

        // --- Initialization & State ---
        init();

        function init() { loadState(); render(); }

        function loadState() { /* ... unchanged state loading logic ... */
            let loadedState = null; try { loadedState = JSON.parse(localStorage.getItem(STORAGE_KEY)) || null; } catch (e) { console.error("Failed to parse state:", e); loadedState = null; }
            let timerConfig = { durationMinutes: 5, timeRemaining: 300, isPaused: false, isActive: false };
            if (loadedState && loadedState.timerConfig) { timerConfig.durationMinutes = parseInt(loadedState.timerConfig.durationMinutes, 10) || 5; if (!loadedState.timerConfig.isActive) { timerConfig.timeRemaining = timerConfig.durationMinutes * 60; } else { timerConfig.timeRemaining = parseInt(loadedState.timerConfig.timeRemaining, 10) || timerConfig.durationMinutes * 60; } timerConfig.isPaused = loadedState.timerConfig.isPaused || false; timerConfig.isActive = loadedState.timerConfig.isActive || false; }
            if (loadedState) { loadedState.timerConfig = timerConfig; }
             // Initialize last match info if needed
             if (loadedState && !loadedState.lastCompletedMatchInfo) {
                  loadedState.lastCompletedMatchInfo = null;
             }
            state = loadedState; console.log("State loaded:", JSON.parse(JSON.stringify(state || {})));
        }

        function saveState() { /* ... unchanged ... */ if (state) { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); /* console.log("State saved."); */ } else { localStorage.removeItem(STORAGE_KEY); console.log("State is null, storage cleared."); } }
        function clearState() { localStorage.removeItem(STORAGE_KEY); state = null; stopCamera(); stopTimer(); stopTicker(); console.log("State cleared."); }

        // --- Camera Handling ---
        async function setupCamera() { /* ... unchanged ... */ if (cameraStream) return; if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { console.warn("getUserMedia not supported"); return; } try { const constraints = { video: { facingMode: "environment" }, audio: false }; cameraStream = await navigator.mediaDevices.getUserMedia(constraints); cameraVideo.srcObject = cameraStream; console.log("Camera stream started."); } catch (err) { console.error("Error accessing camera:", err); cameraVideo.style.backgroundColor = '#222'; } }
        function stopCamera() { /* ... unchanged ... */ if (cameraStream) { cameraStream.getTracks().forEach(track => track.stop()); cameraStream = null; cameraVideo.srcObject = null; console.log("Camera stream stopped."); } }

        // --- Timer Handling ---
        function startTimer(durationSeconds) { /* ... unchanged ... */ stopTimer(); if (!state || !state.timerConfig) return; state.timerConfig.timeRemaining = durationSeconds; state.timerConfig.isPaused = false; state.timerConfig.isActive = true; updateTimerDisplay(); timerInterval = setInterval(() => { if (!state.timerConfig.isPaused && state.timerConfig.isActive) { state.timerConfig.timeRemaining--; updateTimerDisplay(); if (state.timerConfig.timeRemaining <= 0) { finalizeMatch(); } } }, 1000); saveState(); console.log("Timer started"); }
        function pauseTimer() { /* ... unchanged ... */ if (timerInterval && state.timerConfig.isActive) { state.timerConfig.isPaused = true; updateTimerDisplay(); document.getElementById('pause-resume-button').textContent = '▶'; saveState(); console.log("Timer paused"); } }
        function resumeTimer() { /* ... unchanged ... */ if (timerInterval && state.timerConfig.isActive) { state.timerConfig.isPaused = false; updateTimerDisplay(); document.getElementById('pause-resume-button').textContent = '❚❚'; saveState(); console.log("Timer resumed"); } }
        function stopTimer() { /* ... unchanged ... */ clearInterval(timerInterval); timerInterval = null; if(state && state.timerConfig) { state.timerConfig.isActive = false; state.timerConfig.isPaused = false; saveState(); } console.log("Timer stopped"); }
        function updateTimerDisplay() { /* ... unchanged ... */ if (!state || !state.timerConfig) return; const timerElement = document.getElementById('timer'); if (!timerElement) return; const time = Math.max(0, state.timerConfig.timeRemaining); const minutes = Math.floor(time / 60); const seconds = time % 60; timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; timerElement.classList.toggle('paused', state.timerConfig.isPaused); }

        // --- Ticker Handling ---
         function startTicker() {
             stopTicker(); // Clear previous interval
             console.log("Starting previous match ticker");
             const tickerElement = document.getElementById('previous-match-ticker');
             if (!tickerElement) return;

             const showTick = () => {
                  if (state && state.lastCompletedMatchInfo) {
                       const { p1Name, p2Name, score } = state.lastCompletedMatchInfo;
                       tickerElement.textContent = `Last: ${p1Name} ${score[0]} - ${score[1]} ${p2Name}`;
                       tickerElement.classList.remove('animate'); // Remove previous animation class
                       void tickerElement.offsetWidth; // Trigger reflow
                       tickerElement.classList.add('animate'); // Add class to trigger animation
                  } else {
                       tickerElement.textContent = ''; // Clear if no info
                       tickerElement.classList.remove('animate');
                  }
             };

             showTick(); // Show immediately once
             tickerInterval = setInterval(showTick, 15000); // Repeat every 15 seconds
         }

         function stopTicker() {
              clearInterval(tickerInterval);
              tickerInterval = null;
              const tickerElement = document.getElementById('previous-match-ticker');
              if (tickerElement) {
                   tickerElement.classList.remove('animate');
                   tickerElement.style.opacity = 0; // Hide it
              }
              console.log("Ticker stopped");
         }

        // --- Score Handling (FIXED) ---
        function incrementScore(playerIdentifier) {
             // Allow score changes even if timer is paused, but not if match isn't active
             if (!state || !state.timerConfig.isActive) {
                  console.log("Score change prevented: Timer not active.");
                  return;
             }

             let match;
             let isPlayoff = state.phase === 'playoff';

             try { // Add try block for safety
                 if (isPlayoff) {
                      if (state.currentPlayoffRoundIdx < 0 || state.currentPlayoffRoundIdx >= state.playoffRounds.length ||
                          state.currentPlayoffMatchIdx < 0 || state.currentPlayoffMatchIdx >= state.playoffRounds[state.currentPlayoffRoundIdx].length) {
                          console.error("incrementScore: Invalid playoff index."); return;
                      }
                      match = state.playoffRounds[state.currentPlayoffRoundIdx][state.currentPlayoffMatchIdx];
                 } else { // Group
                      if (state.currentGroupIdx < 0 || state.currentGroupIdx >= state.groups.length ||
                           state.groups[state.currentGroupIdx].currentMatchIdx >= state.groups[state.currentGroupIdx].matches.length) {
                           console.error("incrementScore: Invalid group index."); return;
                      }
                      const group = state.groups[state.currentGroupIdx];
                      match = group.matches[group.currentMatchIdx];
                 }
             } catch (error) {
                  console.error("Error accessing match data in incrementScore:", error);
                  return;
             }


             if (!match.liveScore) match.liveScore = [0, 0];

             if (playerIdentifier === 'p1') { match.liveScore[0]++; }
             else { match.liveScore[1]++; }

             // Update UI
             document.getElementById('player1-score').textContent = match.liveScore[0];
             document.getElementById('player2-score').textContent = match.liveScore[1];

             console.log(`Score updated: ${match.liveScore[0]} - ${match.liveScore[1]}`);
             saveState(); // Save intermediate score immediately
        }


        // --- Match Finalization ---
        function finalizeMatch() { /* ... (Update lastCompletedMatchInfo here) ... */
             console.log("Attempting to finalize match...");
             stopTimer(); // Stop timer first

             let match, score1, score2, p1Obj, p2Obj, p1Name, p2Name;
             let isPlayoff = state.phase === 'playoff';
             let canProceed = true;

             try { // Added try block
                if (isPlayoff) {
                    const roundIdx = state.currentPlayoffRoundIdx; const matchIdx = state.currentPlayoffMatchIdx;
                    if (roundIdx < 0 || roundIdx >= state.playoffRounds.length || matchIdx >= state.playoffRounds[roundIdx].length) throw new Error("Invalid playoff index.");
                    match = state.playoffRounds[roundIdx][matchIdx];
                    score1 = match.liveScore ? match.liveScore[0] : 0; score2 = match.liveScore ? match.liveScore[1] : 0;
                    p1Obj = match.p1; p2Obj = match.p2; p1Name = p1Obj.name; p2Name = p2Obj.name;

                    if (score1 === score2) {
                        alert("Playoff Draw!\nIncrement score for the winner using '+', then click 'Exit Match' again.");
                        canProceed = false;
                    } else {
                         recordPlayoffScore(roundIdx, matchIdx, score1, score2); // Advances state
                         state.lastCompletedMatchInfo = { p1Name, p2Name, score: [score1, score2] }; // Update ticker info
                    }
                } else { // Group Stage
                    const groupIdx = state.currentGroupIdx;
                    if (groupIdx < 0 || groupIdx >= state.groups.length) throw new Error("Invalid group index.");
                    const group = state.groups[groupIdx];
                    const matchIdx = group.currentMatchIdx;
                    if (matchIdx >= group.matches.length) throw new Error("Invalid group match index.");
                    match = group.matches[matchIdx];
                    const p1Idx = match.p1Idx; const p2Idx = match.p2Idx;
                    score1 = match.liveScore ? match.liveScore[0] : 0; score2 = match.liveScore ? match.liveScore[1] : 0;
                    p1Obj = group.players[p1Idx]; p2Obj = group.players[p2Idx]; p1Name = p1Obj.name; p2Name = p2Obj.name;

                    recordScore(group, p1Idx, p2Idx, score1, score2); // Advances state
                    state.lastCompletedMatchInfo = { p1Name, p2Name, score: [score1, score2] }; // Update ticker info
                }
             } catch(error) {
                  console.error("Error during finalizeMatch data retrieval:", error);
                  alert("An error occurred trying to finalize the match. Please check console.");
                  canProceed = false; // Don't proceed if data fetch failed
             }


             console.log(`Match Finalized Score: ${p1Name} ${score1} - ${score2} ${p2Name}`);

             if (canProceed) {
                saveState();
                switchToNonStreamView(); // Transition UI
             } else {
                console.log("Match finalization halted (e.g., playoff draw). User action required.");
             }
        }


        // --- Core Rendering Logic (Refined) ---
        function render() { /* ... (Logic largely unchanged, ensure stopTicker is called) ... */
            appDiv.style.display = 'none'; streamContainer.style.display = 'none';
            stopCamera(); stopTicker(); // Ensure ticker stops when not in stream view

            // console.log("Render: Phase=", state ? state.phase : 'null');

            if (!state) { /* ... renderCreateForm ... */
                console.log("Render -> Create Form"); renderCreateForm(appDiv); appDiv.style.display = 'flex';
            } else if (state.phase === 'completed') { /* ... renderChampion ... */
                console.log("Render -> Champion Screen"); renderChampion(appDiv); appDiv.style.display = 'flex';
            } else if (state.phase === 'playoff') { /* ... check indices, renderStreamView ... */
                 const roundIdx = state.currentPlayoffRoundIdx; const matchIdx = state.currentPlayoffMatchIdx;
                 if (roundIdx >= 0 && roundIdx < state.playoffRounds.length && matchIdx >= 0 && matchIdx < state.playoffRounds[roundIdx].length) { console.log("Render -> Playoff Stream View"); renderStreamView(); streamContainer.style.display = 'block'; }
                 else { console.warn("Render: Playoff phase, invalid index."); renderBracket(appDiv); appDiv.style.display = 'flex'; }
            } else if (state.phase === 'group') { /* ... check indices, renderStreamView or finishGroupStage ... */
                 const groupIdx = state.currentGroupIdx; let playableGroupFound = false;
                 if (groupIdx >= 0 && groupIdx < state.groups.length) { const currentGroup = state.groups[groupIdx]; if (!currentGroup.isComplete && currentGroup.currentMatchIdx < currentGroup.matches.length) { playableGroupFound = true; } }
                 if (playableGroupFound) { console.log("Render -> Group Stream View"); renderStreamView(); streamContainer.style.display = 'block'; }
                 else { const allGroupsComplete = state.groups.every(g => g.isComplete); if (allGroupsComplete) { if (state.phase === 'group') { console.log("Render: All groups complete -> finishing..."); finishGroupStage(); return; } else { console.warn("Render: Group phase ended, but stuck?"); renderCreateForm(appDiv); appDiv.style.display = 'flex';} } else { console.warn("Render: Group phase, current invalid, but not all complete."); renderCreateForm(appDiv); appDiv.style.display = 'flex'; } }
            } else if (state.phase === 'playoff_selection') { /* ... renderPlayoffSelection + Start button ... */
                 console.log("Render -> Playoff Selection Screen"); renderPlayoffSelection(appDiv);
                 const startButton = btn("Start First Playoff Match"); startButton.style.marginTop = '1rem'; startButton.onclick = () => { if (state.phase === 'playoff_selection' && state.playoffRounds && state.playoffRounds.length > 0 && state.playoffRounds[0].length > 0) { state.phase = 'playoff'; state.currentPlayoffRoundIdx = 0; state.currentPlayoffMatchIdx = 0; saveState(); render(); } else { console.error("Playoff state not ready."); alert("Error: Playoff data not found."); } };
                 if (!document.getElementById('start-playoff-btn')) { startButton.id = 'start-playoff-btn'; appDiv.appendChild(startButton); }
                 appDiv.style.display = 'flex';
            } else { /* ... Fallback ... */
                console.error("Render: Unknown state phase:", state ? state.phase : 'null', "-> Fallback"); renderCreateForm(appDiv); appDiv.style.display = 'flex';
            }
        }

        // --- Setup ---
        function renderCreateForm(app) { /* ... unchanged ... */ app.innerHTML = ''; const card = div('div', 'card'); const settingsCont = div('div'); const listCont = div('div'); const addBtn = btn('Add Player'); const startBtn = btn('Start Tournament', 'secondary'); const groupSizeRow = div('div', 'settings-row'); groupSizeRow.innerHTML = `<label for="maxGroupSizeInput">Max Players per Group:</label><input type="number" id="maxGroupSizeInput" min="2" value="4" class="player-input" style="width: 60px; flex-grow: 0;">`; const timerRow = div('div', 'settings-row'); const currentConfigDuration = (state && state.timerConfig && state.timerConfig.durationMinutes) ? state.timerConfig.durationMinutes : 5; timerRow.innerHTML = `<label for="matchDurationInput">Match Length (minutes):</label><input type="number" id="matchDurationInput" min="1" value="${currentConfigDuration}" class="player-input" style="width: 60px; flex-grow: 0;">`; settingsCont.append(groupSizeRow, timerRow); card.append(settingsCont, listCont, addBtn, startBtn); app.append(card); let players = []; function refreshPlayerList() { listCont.innerHTML = ''; players.forEach((p, i) => { const row = div('div', 'player-row'); const dot = div('div', 'player-color-static'); dot.style.background = p.color; dot.onclick = () => { p.color = randomColor(); dot.style.background = p.color; inpColor.value = p.color; }; const inpName = document.createElement('input'); inpName.placeholder = 'Name'; inpName.className = 'player-input'; inpName.value = p.name; inpName.oninput = e => p.name = e.target.value; const inpColor = document.createElement('input'); inpColor.type = 'color'; inpColor.value = p.color; inpColor.oninput = e => { p.color = e.target.value; dot.style.background = p.color; }; const del = btn('x', 'secondary'); del.onclick = () => { players.splice(i, 1); refreshPlayerList(); }; row.append(dot, inpName, inpColor, del); listCont.append(row); }); } addBtn.onclick = () => { players.push({ id: 'P' + Date.now() + players.length, name: '', color: randomColor() }); refreshPlayerList(); }; startBtn.onclick = () => { const cleanPlayers = players.filter(p => p.name.trim()); const maxGroupSize = parseInt(document.getElementById('maxGroupSizeInput').value, 10); const matchDuration = parseInt(document.getElementById('matchDurationInput').value, 10); if (cleanPlayers.length < 2) { alert('Need at least 2 players'); return; } if (isNaN(maxGroupSize) || maxGroupSize < 2) { alert('Max players per group must be at least 2'); return; } if (isNaN(matchDuration) || matchDuration < 1) { alert('Match duration must be at least 1 minute.'); return; } const timerConfig = { durationMinutes: matchDuration, timeRemaining: matchDuration * 60, isPaused: false, isActive: false }; startTournament(cleanPlayers, maxGroupSize, timerConfig); }; refreshPlayerList(); }
        function startTournament(initialPlayers, maxGroupSize, timerConfig) { /* ... unchanged ... */ shuffle(initialPlayers); const groupsData = []; for (let i = 0; i < initialPlayers.length; i += maxGroupSize) { groupsData.push(initialPlayers.slice(i, i + maxGroupSize)); } if (groupsData.length > 1 && groupsData[groupsData.length - 1].length < 2) { const lastGroup = groupsData.pop(); lastGroup.forEach((player, index) => groupsData[index % groupsData.length].push(player)); } const finalGroups = groupsData.map((groupPlayers, index) => { const playersInGroup = groupPlayers.map(p => ({ ...p, points: 0, played: 0, wins: 0, draws: 0, losses: 0, goalsFor: 0, goalsAgainst: 0 })); return { id: index + 1, players: playersInGroup, matches: generateMatches(playersInGroup), currentMatchIdx: 0, isComplete: false, lastMatch: null }; }); finalGroups.forEach(group => shuffle(group.matches)); state = { phase: 'group', groups: finalGroups, currentGroupIdx: 0, timerConfig: timerConfig, playoffQualifiers: [], playoffRounds: [], currentPlayoffRoundIdx: -1, currentPlayoffMatchIdx: -1, champion: null, lastCompletedMatchInfo: null }; console.log("Tournament Started. Initial State:", JSON.parse(JSON.stringify(state))); saveState(); render(); }

        // --- Group Stage ---
        function recordScore(group, p1Idx, p2Idx, score1, score2) { /* ... unchanged ... */ const p1 = group.players[p1Idx]; const p2 = group.players[p2Idx]; if(isNaN(score1) || isNaN(score2)) return; p1.played++; p2.played++; p1.goalsFor += score1; p1.goalsAgainst += score2; p2.goalsFor += score2; p2.goalsAgainst += score1; if (score1 > score2) { p1.wins++; p1.points += 3; p2.losses++; } else if (score2 > score1) { p2.wins++; p2.points += 3; p1.losses++; } else { p1.draws++; p1.points += 1; p2.draws++; p2.points += 1; } group.matches[group.currentMatchIdx].score = [score1, score2]; group.lastMatch = { p1Name: p1.name, p2Name: p2.name, score: [score1, score2] }; group.currentMatchIdx++; if (group.currentMatchIdx >= group.matches.length) { group.isComplete = true; } }

        // --- Playoff Setup ---
        function finishGroupStage() { /* ... unchanged ... */ console.log("Finishing group stage..."); state.phase = 'playoff_selection'; let groupWinners = []; let allRunnersUp = []; let addedRunnerUp = null; state.groups.forEach(group => { const sortedPlayers = [...group.players].sort(comparePlayers); if(sortedPlayers.length > 0) groupWinners.push({...sortedPlayers[0], sourceGroup: group.id}); if(sortedPlayers.length > 1) allRunnersUp.push({...sortedPlayers[1], sourceGroup: group.id}); }); let playoffQualifiers = [...groupWinners]; if (groupWinners.length % 2 !== 0 && allRunnersUp.length > 0) { allRunnersUp.sort(comparePlayers); const bestRunnerUp = allRunnersUp[0]; if (!playoffQualifiers.some(p => p.id === bestRunnerUp.id)) { playoffQualifiers.push(bestRunnerUp); addedRunnerUp = bestRunnerUp; } } state.playoffQualifiers = playoffQualifiers; startPlayoffs(groupWinners, addedRunnerUp); console.log("Group stage finished, state prepared for playoff selection."); saveState(); render(); }
        function startPlayoffs(groupWinners, addedRunnerUp) { /* ... unchanged ... */ console.log("Setting up playoff bracket..."); const qualifiers = [...state.playoffQualifiers]; shuffle(qualifiers); const firstRoundMatches = []; let remainingQualifiers = [...qualifiers]; if (addedRunnerUp && groupWinners.length > 0) { const sortedWinners = [...groupWinners].sort(comparePlayers); const bestWinner = sortedWinners[0]; const bestWinnerIdx = remainingQualifiers.findIndex(p => p.id === bestWinner.id); const runnerUpIdx = remainingQualifiers.findIndex(p => p.id === addedRunnerUp.id); if (bestWinnerIdx !== -1 && runnerUpIdx !== -1) { const p1 = remainingQualifiers.splice(bestWinnerIdx, 1)[0]; const adjustedRunnerUpIdx = (runnerUpIdx > bestWinnerIdx) ? runnerUpIdx - 1 : runnerUpIdx; const p2 = remainingQualifiers.splice(adjustedRunnerUpIdx, 1)[0]; firstRoundMatches.push({ p1, p2, score: null, winner: null, roundIdx: 0, matchIdx: 0, liveScore: [0,0] }); } else { console.warn("Seeding failed."); remainingQualifiers = [...qualifiers];} } let matchCounter = firstRoundMatches.length; while (remainingQualifiers.length >= 2) { const p1 = remainingQualifiers.pop(); const p2 = remainingQualifiers.pop(); firstRoundMatches.push({ p1, p2, score: null, winner: null, roundIdx: 0, matchIdx: matchCounter++, liveScore: [0,0] }); } state.playoffRounds = [firstRoundMatches]; state.currentPlayoffRoundIdx = -1; state.currentPlayoffMatchIdx = -1; console.log("Playoff bracket generated:", state.playoffRounds); }

        // --- Playoff Gameplay ---
        function recordPlayoffScore(roundIdx, matchIdx, score1, score2) { /* ... unchanged ... */ const match = state.playoffRounds[roundIdx][matchIdx]; match.score = [score1, score2]; match.winner = (score1 > score2) ? match.p1 : match.p2; const currentRound = state.playoffRounds[roundIdx]; const isLastMatchOfRound = (matchIdx === currentRound.length - 1); if (isLastMatchOfRound) { const winners = currentRound.map(m => m.winner).filter(Boolean); if (winners.length === 1) { finishTournament(winners[0]); return; } else if (winners.length > 1) { generateNextRound(winners); state.currentPlayoffRoundIdx++; state.currentPlayoffMatchIdx = 0; } else { console.error("No winners found?"); state.currentPlayoffMatchIdx++; } } else { state.currentPlayoffMatchIdx++; } }
        function generateNextRound(winners) { /* ... unchanged ... */ console.log(`Generating round ${state.currentPlayoffRoundIdx + 2}`); const nextRoundMatches = []; const remainingWinners = [...winners]; shuffle(remainingWinners); let matchCounter = 0; while (remainingWinners.length >= 2) { const p1 = remainingWinners.pop(); const p2 = remainingWinners.pop(); nextRoundMatches.push({ p1, p2, score: null, winner: null, roundIdx: state.currentPlayoffRoundIdx + 1, matchIdx: matchCounter++, liveScore: [0,0] }); } state.playoffRounds.push(nextRoundMatches); }


        // --- Stream View Rendering (NEW LAYOUT) ---
        function renderStreamView() {
            setupCamera();
            startTicker(); // Start the previous match ticker

            let match, p1, p2, roundInfoText = "";
            let score1 = 0, score2 = 0;

            try {
                if (state.phase === 'group') {
                    const group = state.groups[state.currentGroupIdx]; match = group.matches[group.currentMatchIdx];
                    p1 = group.players[match.p1Idx]; p2 = group.players[match.p2Idx];
                    roundInfoText = `Group ${group.id} - M ${group.currentMatchIdx + 1}/${group.matches.length}`;
                } else {
                    const roundIdx = state.currentPlayoffRoundIdx; const matchIdx = state.currentPlayoffMatchIdx;
                    const round = state.playoffRounds[roundIdx]; match = round[matchIdx];
                    p1 = match.p1; p2 = match.p2;
                    const isFinal = round.length === 1 && roundIdx > 0;
                    roundInfoText = isFinal ? 'Final' : `Playoffs R${roundIdx + 1} - M ${matchIdx + 1}/${round.length}`;
                }
                if (!match.liveScore) match.liveScore = [0, 0];
                score1 = match.liveScore[0]; score2 = match.liveScore[1];
            } catch (error) { console.error("Error getting match data:", error); roundInfoText = "Error"; return; }

            // --- Populate Overlay ---
            const el = (id) => document.getElementById(id);
            el('match-info').textContent = roundInfoText;
            el('player1-name').textContent = p1.name; el('player1-name').style.color = p1.color;
            el('player1-score').textContent = score1;
            el('player2-name').textContent = p2.name; el('player2-name').style.color = p2.color;
            el('player2-score').textContent = score2;

            // Timer
            if (!state.timerConfig.isActive) { startTimer(state.timerConfig.timeRemaining || state.timerConfig.durationMinutes * 60); }
            updateTimerDisplay();

            // --- Event Listeners (Re-attach ensuring correct target) ---
             // Use event delegation or ensure elements exist before adding listener
            const p1GoalBtn = el('player1-goal-button');
            const p2GoalBtn = el('player2-goal-button');
            const pauseResumeBtn = el('pause-resume-button');
            const exitBtn = el('exit-stream-button');

             if(p1GoalBtn) p1GoalBtn.onclick = () => incrementScore('p1'); else console.error("P1 Goal Btn not found");
             if(p2GoalBtn) p2GoalBtn.onclick = () => incrementScore('p2'); else console.error("P2 Goal Btn not found");
             if(pauseResumeBtn) { pauseResumeBtn.onclick = () => { if (state.timerConfig.isPaused) resumeTimer(); else pauseTimer(); }; pauseResumeBtn.textContent = state.timerConfig.isPaused ? '▶' : '❚❚'; } else console.error("Pause Btn not found");
             if(exitBtn) exitBtn.onclick = () => { if (state.timerConfig.isActive && state.timerConfig.timeRemaining > 0 && !state.timerConfig.isPaused) { if (!confirm("Timer running! Finalize with current score?")) return; } else if (state.phase === 'playoff' && match.liveScore[0] === match.liveScore[1]) { /* No confirm for playoff draw */ } else { if (!confirm("Finalize match with current score?")) return; } finalizeMatch(); }; else console.error("Exit Btn not found");
        }

        function switchToNonStreamView() { /* ... (Added stopTicker) ... */ stopCamera(); stopTimer(); stopTicker(); streamContainer.style.display = 'none'; appDiv.style.display = 'flex'; render(); }

        // --- Champion / Bracket / Standings / Viz / Helpers (mostly unchanged) ---
        function finishTournament(champion) { console.log("Tournament Finished! Champion:", champion.name); state.phase = 'completed'; state.champion = champion; saveState(); render(); }
        function renderChampion(app) { /* ... unchanged ... */ app.innerHTML = ''; const card = div('div', 'card champion-box'); card.append(div('h2', 'section-title', 'Tournament Champion!')); if (state.champion) { const champBox = div('div'); const dot = div('div', 'player-color-static'); dot.style.background = state.champion.color; dot.style.width = 'clamp(60px, 15vh, 80px)'; dot.style.height = 'clamp(60px, 15vh, 80px)'; dot.style.margin = '0 auto 0.5rem auto'; const nm = div('div', 'player-name', state.champion.name); nm.style.fontSize = 'calc(var(--font-size-large) * 1.1)'; nm.style.fontWeight = 'bold'; champBox.append(dot, nm); card.append(champBox); } else { card.append(div('p', '', 'Error: Champion data not found.')); } const restart = btn('New Tournament'); restart.onclick = () => { clearState(); render(); }; card.append(restart); app.append(card); if(state.playoffRounds && state.playoffRounds.length > 0) renderBracket(app); if(state.groups) state.groups.forEach(group => renderGroupStandings(app, group)); }
        function renderBracket(app) { /* ... unchanged ... */ const bracketContainer = div('div', 'card playoff-bracket'); bracketContainer.append(div('h3', 'section-title', 'Playoff Bracket')); if (!state || !state.playoffRounds) return; state.playoffRounds.forEach((round, roundIndex) => { const roundDiv = div('div', 'playoff-round'); roundDiv.append(div('h4', '', `Round ${roundIndex + 1}`)); round.forEach(match => { const matchDiv = div('div', 'playoff-match'); const p1BoxEl = playerBox(match.p1); const p2BoxEl = playerBox(match.p2); const scoreDiv = div('div', 'match-score'); if (match.score !== null) { scoreDiv.textContent = `${match.score[0]} - ${match.score[1]}`; if (match.winner) { if (match.winner.id === match.p1.id) { p1BoxEl.querySelector('.pname').classList.add('winner'); p2BoxEl.querySelector('.pname').classList.add('loser'); } else { p2BoxEl.querySelector('.pname').classList.add('winner'); p1BoxEl.querySelector('.pname').classList.add('loser'); } } } else { scoreDiv.textContent = 'vs'; } matchDiv.append(p1BoxEl, scoreDiv, p2BoxEl); roundDiv.append(matchDiv); }); bracketContainer.append(roundDiv); }); app.append(bracketContainer); }
        function renderGroupStandings(app, group) { /* ... unchanged ... */ const st = div('div', 'card standings'); const groupTitle = div('h3', '', `Group ${group.id} Standings`); st.append(groupTitle); const table = document.createElement('table'); table.innerHTML = `<thead><tr><th class="player-name-col">Player</th><th>Pts</th><th>Pld</th><th>W</th><th>D</th><th>L</th><th>GF</th><th>GA</th><th>GD</th></tr></thead>`; const tbody = document.createElement('tbody'); const sortedPlayers = [...group.players].sort(comparePlayers); sortedPlayers.forEach(p => { const tr = document.createElement('tr'); const gd = p.goalsFor - p.goalsAgainst; tr.innerHTML = `<td class="player-name-col"><span style="color:${p.color}">${p.name}</span></td><td>${p.points}</td><td>${p.played}</td><td>${p.wins}</td><td>${p.draws}</td><td>${p.losses}</td><td>${p.goalsFor}</td><td>${p.goalsAgainst}</td><td>${gd > 0 ? '+' : ''}${gd}</td>`; tbody.append(tr); }); table.append(tbody); st.append(table); app.append(st); }
        function renderPlayoffSelection(app) { /* ... unchanged ... */ app.innerHTML = ''; const card = div('div', 'card'); card.append(div('h2', 'section-title', 'Playoff Qualifiers')); const qualifierList = div('div'); qualifierList.style.display = 'flex'; qualifierList.style.flexWrap = 'wrap'; qualifierList.style.justifyContent = 'center'; state.playoffQualifiers.forEach(p => { const box = playerBox(p); box.style.margin = '0.5rem'; qualifierList.append(box); }); card.append(qualifierList); app.append(card); const vizContainer = div('div', 'visualization card'); vizContainer.append(div('h3', 'group-title', 'Advancement Visualization')); const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'); svg.setAttribute('viewBox', '0 0 300 150'); vizContainer.append(svg); app.append(vizContainer); renderBasicVisualization(svg, state.playoffQualifiers); }
        function comparePlayers(a, b) { /* ... unchanged ... */ const gdA = a.goalsFor - a.goalsAgainst; const gdB = b.goalsFor - b.goalsAgainst; if (b.points !== a.points) return b.points - a.points; if (gdB !== gdA) return gdB - gdA; if (b.goalsFor !== a.goalsFor) return b.goalsFor - a.goalsFor; return a.name.localeCompare(b.name); }
        function shuffle(a) { /* ... unchanged ... */ for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } }
        function div(tag, cls = '', text = '') { /* ... unchanged ... */ const d = document.createElement(tag); if (cls) d.className = cls; if (text) d.textContent = text; return d; }
        function btn(text, cls = '') { /* ... unchanged ... */ const b = document.createElement('button'); b.textContent = text; if (cls) b.className = cls; return b; }
        function playerBox(p) { /* ... unchanged ... */ const box = div('div', 'p-box'); const dot = div('div', 'player-color-static'); dot.style.background = p.color? p.color : '#ccc'; const nm = div('div', 'pname', p.name? p.name : 'TBD'); box.append(dot, nm); return box; }
        function randomColor() { /* ... unchanged ... */ return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0'); }
        function generateMatches(groupPlayers) { /* ... unchanged ... */ const matches = []; const pIdx = groupPlayers.map((_, i) => i); for (let i = 0; i < pIdx.length; i++) { for (let j = i + 1; j < pIdx.length; j++) { matches.push({ p1Idx: pIdx[i], p2Idx: pIdx[j], score: null, liveScore:[0,0] }); } } return matches; }
        function renderBasicVisualization(svg, qualifiers) { /* ... unchanged ... */ svg.innerHTML = ''; if (!qualifiers || qualifiers.length === 0) return; const width = 300; const height = 150; const nodeRadius = 8; const padding = 20; const targetY = height - padding - 15; const targetX = width / 2; const playoffText = document.createElementNS('http://www.w3.org/2000/svg', 'text'); playoffText.setAttribute('x', targetX); playoffText.setAttribute('y', targetY + 10); playoffText.setAttribute('class', 'playoff-area-text'); playoffText.textContent = 'Playoffs'; svgElement.appendChild(playoffText); const numQ = qualifiers.length; qualifiers.forEach((p, i) => { const angle = (Math.PI * (i + 0.5)) / numQ; const sX = targetX + (width / 2 - padding * 2) * Math.cos(angle - Math.PI / 2); const sY = (height / 2) - (height / 3) * Math.sin(angle - Math.PI / 2); const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('x1', sX); line.setAttribute('y1', sY); line.setAttribute('x2', targetX); line.setAttribute('y2', targetY); line.setAttribute('class', 'qualifier-line'); svgElement.appendChild(line); const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); circle.setAttribute('cx', sX); circle.setAttribute('cy', sY); circle.setAttribute('r', nodeRadius); circle.setAttribute('fill', p.color); circle.setAttribute('stroke', '#fff'); circle.setAttribute('stroke-width', '1'); svgElement.appendChild(circle); const text = document.createElementNS('http://www.w3.org/2000/svg', 'text'); text.setAttribute('x', sX); text.setAttribute('y', sY - nodeRadius - 2); text.setAttribute('class', 'qualifier-text'); text.textContent = p.name; svgElement.appendChild(text); }); }


    })();
    </script>
</body>
</html>
